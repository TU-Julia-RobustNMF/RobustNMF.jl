var documenterSearchIndex = {"docs":
[{"location":"functions/#RobustNMF","page":"Functions","title":"RobustNMF","text":"Documentation for RobustNMF.\n\n","category":"section"},{"location":"functions/#RobustNMF.add_gaussian_noise!-Tuple{AbstractMatrix}","page":"Functions","title":"RobustNMF.add_gaussian_noise!","text":"add_gaussian_noise!(X::AbstractMatrix; σ::Float64=0.1, clip_at_zero::Bool=true)\n\nAdd Gaussian noise with standard deviation σ to the matrix X in-place.\n\nIf clip_at_zero is true, replace all negative entries of X with 0.0 after adding noise, to preserve non-negativity.\n\nArguments\n\nX::AbstractMatrix: Data matrix to be corrupted.\n\nKeyword Arguments\n\nσ::Float64=0.1: Noise standard deviation.\nclip_at_zero::Bool=true: Enforce non-negativity after corruption.\n\nReturns\n\nX: The modified input matrix.\n\nExamples\n\njulia> X = abs.(randn(5, 5));\n\njulia> add_gaussian_noise!(X; σ=0.2);\n\njulia> minimum(X) >= 0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.add_sparse_outliers!-Tuple{AbstractMatrix}","page":"Functions","title":"RobustNMF.add_sparse_outliers!","text":"add_sparse_outliers!(X::AbstractMatrix; fraction::Float64=0.01, magnitude::Float64=5.0, \nseed=nothing)\n\nAdd sparcse, large positive outliers to a fraction of the entries of X in-place.\n\nfraction controls the proportion of entries that are modified. Each selected entry is increased by a random value drawn from Uniform(0, magnitude). If seed is provided, the random choices are reproducible.\n\nArguments\n\nX::AbstractMatrix: Data matrix to be corrupted.\n\nKeyword Arguments\n\nfraction::Float64=0.01: Fraction of entries to corrupt.\nmagnitude::Float64=5.0: Maximum outlier amplitude.\nseed: Optional random seed.\n\nReturns\n\nX: The modified input matrix.\n\nExamples\n\njulia> X = zeros(10, 10);\n\njulia> add_sparse_outliers!(X; fraction=0.05, seed=1);\n\njulia> count(x -> x > 0, X) > 0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.generate_synthetic_data-Tuple{Int64, Int64}","page":"Functions","title":"RobustNMF.generate_synthetic_data","text":"generate_synthetic_data(m::Int, n::Int; rank::Int=10, noise_level::Float64=0.0, seed=nothing)\n\nGenerate a non-negative matrix X ∈ R^{m×n} by sampling non-negative factors W (m×rank) and H (rank×n) and returning (X, W, H).\n\nOptionally add Gaussian noise with standard deviation noise_level and clip the result at 0.0 to keep X non-negative.\n\nArguments\n\nm::Int: Number of rows of X.\nn::Int: Number of columns of X.\n\nKeyword Arguments\n\nrank::Int=10: Rank of the factorization.\nnoise_level::Float64=0.0: Standard deviation of Gaussian noise.\nseed: Optional random seed for reproducibility.\n\nReturns\n\nX::Matrix{Float64}: Generated non-negative data matrix.\nW::Matrix{Float64}: Left factor.\nH::Matrix{Float64}: Right factor.\n\nExamples\n\njulia> X, W, H = generate_synthetic_data(20, 15; rank=3, seed=42);\n\njulia> size(W), size(H)\n((20, 3), (3, 15))\n\njulia> minimum(X) >= 0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.load_image_folder-Tuple{AbstractString}","page":"Functions","title":"RobustNMF.load_image_folder","text":"load_image_folder(dir::AbstractString; pattern::AbstractString=\"*.png\", normalize::Bool=true)\n\nLoad all images in dir whose filenames match pattern, convert them to grayscale if needed, flatten them, and stack them as columns of a data matrix X.\n\nReturns a tuple (X, (height, width), filenames), where:\n\nX :: Matrix{Float64} has one column per image,\n(height, width) is the original image size,\nfilenames is a vector of the loaded base filenames.\n\nIf normalize is true, the matrix X is shifted and rescaled to be non-negative with entries in [0, 1].\n\nArguments\n\ndir::AbstractString: Path to the image directory.\n\nKeyword Arguments\n\npattern::AbstractString=\"*.png\": File extension filter.\nnormalize::Bool=true: Normalize output matrix to [0, 1].\n\nReturns\n\nX::Matrix{Float64}: One column per image.\n(height, width): Original image dimensions.\nfilenames::Vector{String}: Loaded file names.\n\nExamples\n\njulia> # X, size, names = load_image_folder(\"faces/\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.nmf-Tuple{Any}","page":"Functions","title":"RobustNMF.nmf","text":" nmf(X; rank::Int=10, maxiter::Int=500, tol::Float64=1e-4)\n\nCompute a standard Non-negative Matrix Factorization (NMF) of the non-negative data matrix X ∈ ℝ^{m×n} using multiplicative update rules and an L2 (Frobenius) reconstruction loss. \n\nReturns\n\nW: non-negative basis matrix of size (m, rank)\nH: non-negative coefficient matrix of size (rank, n)\nhistory: vector containing the Frobenius reconstruction error at each iteration\n\nThe reconstructed data matrix can be obtained as W * H.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.normalize_nonnegative!-Tuple{AbstractMatrix}","page":"Functions","title":"RobustNMF.normalize_nonnegative!","text":"normalize_nonnegative!(X::AbstractMatrix; rescale::Bool=true)\n\nShift the matrix X in-place so that its minimum value becomes 0.0 if it is negative. If rescale is true, also divide X by its maximum value so that all entries lie in the interval [0, 1].\n\nArguments\n\nX::AbstractMatrix: Input matrix.\n\nKeyword Arguments\n\nrescale::Bool=true: Whether to divide by the maximum value.\n\nReturns\n\nX: The normalized matrix.\n\nExamples\n\njulia> X = [-1.0 2.0; 3.0 -4.0];\n\njulia> normalize_nonnegative!(X);\n\njulia> minimum(X), maximum(X)\n(0.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.robust_nmf-Tuple{AbstractMatrix{<:Real}}","page":"Functions","title":"RobustNMF.robust_nmf","text":"robust_nmf(X; rank=2, maxiter=50, tol=1e-4, eps_weight=1e-6, eps_update=1e-12, seed=0)\n\nVery simple robust NMF via IRLS style weighting plus multiplicative updates. Stops early when the relative change in mean absolute error falls below tol.\n\nReturns:     W, H, history where history[k] = mean(abs.(X - W*H)) at iteration k.\n\n\n\n\n\n","category":"method"},{"location":"#Getting-Started-with-RobustNMF.jl","page":"Getting Started","title":"Getting Started with RobustNMF.jl","text":"","category":"section"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"Clone the repository and activate the project environment. The following steps work when executed from the repository root directory.\n\n# Enter the Julia package manager\n]\n\n# Activate the local project environment\nactivate .\n\n# Install all required dependencies\ninstantiate","category":"section"},{"location":"#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"Import the package:\n\nusing RobustNMF","category":"section"},{"location":"#Simple-Example","page":"Getting Started","title":"Simple Example","text":"Perform robust non-negative matrix factorization:\n\n\n# Generate synthetic non-negative data\nX, W, H = generate_synthetic_data(20, 30)\n\n# Add Gaussian noise (in-place)\nadd_gaussian_noise!(X, σ = 0.2)\n\n# Add sparse outliers (in-place)\nadd_sparse_outliers!(X, fraction = 0.04, magnitude = 5.2)\n\n# Normalize and rescale data to non-negative range\nnormalize_nonnegative!(X)\n\n# Run standard NMF\nW_nmf, H_nmf, history = nmf(X, rank = 12, maxiter = 3000, tol = 1e-6)\n\n# Reconstruct the data matrix (X)\nX_rec = W_nmf * H_nmf\n\n# Run robust NMF\nW_robust, H_robust, history_robust = robust_nmf(X, rank = 12, maxiter = 3000, tol = 1e-6)\n\n\n","category":"section"},{"location":"#Notes","page":"Getting Started","title":"Notes","text":"All input data must be non-negative.\nFunctions with a ! modify their input in-place.\nThe reconstructed matrix X_rec approximates the original data X.","category":"section"}]
}
