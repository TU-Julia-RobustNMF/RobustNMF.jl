var documenterSearchIndex = {"docs":
[{"location":"functions/#RobustNMF","page":"Functions","title":"RobustNMF","text":"Documentation for RobustNMF.","category":"section"},{"location":"functions/#Algorithms","page":"Functions","title":"Algorithms","text":"","category":"section"},{"location":"functions/#1.-Standard-NMF","page":"Functions","title":"1. Standard NMF","text":"Standard non-negative matrix factorization helps with clean data without outliers and minimizes the Frobenius norm.\n\nReturns:\n\nW - Basis Matrix (m × rank)\nH - Coefficient Matrix (rank × n)","category":"section"},{"location":"functions/#2.-Robust-NMF-L2,1-norm","page":"Functions","title":"2. Robust NMF - L2,1-norm","text":"RobustNMF with L2,1-norm approach is best for sample-wise outliers and data with corrupted samples (entire columns).\n\nReturns:\n\nF - Basis Matrix (m × rank)\nG - Coefficient Matrix (rank × n)\n\nHelper functions:","category":"section"},{"location":"functions/#Data-Generation-and-Preprocessing","page":"Functions","title":"Data Generation and Preprocessing","text":"","category":"section"},{"location":"functions/#Visualization-Functions","page":"Functions","title":"Visualization Functions","text":"","category":"section"},{"location":"functions/#1.-plot_convergence","page":"Functions","title":"1. plot_convergence","text":"The convergence plot of NMF algorithms shows if the algorithm converged, compares convergence speed between methods, and identifies if more iterations are needed.","category":"section"},{"location":"functions/#2.-plot*basis*vectors","page":"Functions","title":"2. plotbasisvectors","text":"This function helps to visualize the learned basis vectors (W).\n\nEach subplot shows one basis vector\nFor images: Should show meaningful parts (e.g., facial features, object components)\nFor text: Represents topics or themes\n\nExample:\n\nW, H, _ = nmf(X; rank=10)\nplot_basis_vectors(W; max_components=10)\n\n# For image data with known dimensions\nplot_basis_vectors(W; img_shape=(28, 28), max_components=16)","category":"section"},{"location":"functions/#3.-plot*reconstruction*comparison","page":"Functions","title":"3. plotreconstructioncomparison","text":"Shows original data vs. reconstructed data side-by-side. We can visually evaluate reconstruction accuracy and see where algorithm struggles.\n\nExample:\n\nW, H, _ = nmf(X; rank=10)\nX_recon = W * H\nplot_reconstruction_comparison(X, X_recon; img_shape=(28, 28), n_samples=6)","category":"section"},{"location":"functions/#4.-plot*nmf*summary","page":"Functions","title":"4. plotnmfsummary","text":"Creates a comprehensive summary with basis vectors, reconstructions, and convergence.\n\nExample:\n\nW, H, history = nmf(X; rank=10)\nplot_nmf_summary(X, W, H, history; img_shape=(28, 28))","category":"section"},{"location":"functions/#5.-Other-Visualization-Functions","page":"Functions","title":"5. Other Visualization Functions","text":"","category":"section"},{"location":"functions/#Performance-Metrics","page":"Functions","title":"Performance Metrics","text":"","category":"section"},{"location":"functions/#RMSE-(Root-Mean-Square-Error)","page":"Functions","title":"RMSE (Root Mean Square Error)","text":"Measures average reconstruction error\nLower is better\nStandard NMF optimizes this metric\n\nrmse = sqrt(mean((X - W*H).^2))","category":"section"},{"location":"functions/#MAE-(Mean-Absolute-Error)","page":"Functions","title":"MAE (Mean Absolute Error)","text":"Measures average absolute reconstruction error\nLower is better\nBetter metric for comparing robustness\n\nmae = mean(abs.(X - W*H))","category":"section"},{"location":"functions/#Relative-Error","page":"Functions","title":"Relative Error","text":"Error as percentage of data magnitude\nLower is better\nTypical range values: 1-20% approximately\n\nrel_error = norm(X - W*H) / norm(X)","category":"section"},{"location":"functions/#Running-the-Demo","page":"Functions","title":"Running the Demo","text":"To run the demo version of RobustNMF:\n\n# Instantiate your package\nusing Pkg\nPkg.instantiate()\n\n# Run the following command to have the demo version of RobustNMF\ninclude(\"examples/demo_robustnmf.jl\")\n\nAfterwards, you will see the plots that compare Standard NMF and Robust NMF, along with performance metrics such as RMSE and MAE.","category":"section"},{"location":"functions/#RobustNMF.nmf","page":"Functions","title":"RobustNMF.nmf","text":" nmf(X; rank::Int=10, maxiter::Int=500, tol::Float64=1e-4)\n\nCompute a standard Non-negative Matrix Factorization (NMF) of the non-negative data matrix X ∈ ℝ^{m×n} using multiplicative update rules and an L2 (Frobenius) reconstruction loss. \n\nReturns\n\nW: non-negative basis matrix of size (m, rank)\nH: non-negative coefficient matrix of size (rank, n)\nhistory: vector containing the Frobenius reconstruction error at each iteration\n\nThe reconstructed data matrix can be obtained as W * H.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.l21_nmf","page":"Functions","title":"RobustNMF.l21_nmf","text":"l21_nmf(X; rank=10, maxiter=500, tol=1e-4, seed=nothing)\n\nL2,1-Norm Regularized Non-negative Matrix Factorization.\n\nMinimizes: ||X - FG||_{2,1} where the L2,1-norm promotes robustness to sample-wise outliers (entire corrupted columns in X).\n\nArguments\n\nX::AbstractMatrix{<:Real}: Non-negative data matrix (m × n)\n\nKeyword Arguments\n\nrank::Int=10: Number of latent components\nmaxiter::Int=500: Maximum iterations\ntol::Float64=1e-4: Convergence tolerance (absolute error threshold)\nseed::Union{Int,Nothing}=nothing: Random seed for reproducibility\n\nReturns\n\nF::Matrix{Float64}: Basis matrix (m × rank)\nG::Matrix{Float64}: Coefficient matrix (rank × n)\nhistory::Vector{Float64}: L2,1-norm error at each iteration\n\nExamples\n\nX = rand(50, 30)\nF, G, hist = l21_nmf(X; rank=5, maxiter=200)\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.l21_update","page":"Functions","title":"RobustNMF.l21_update","text":"l21_update(X, F, G; eps_update=1e-10)\n\nPerform one iteration of L2,1-NMF multiplicative updates.\n\nThe L2,1-norm promotes row sparsity in the residual matrix, making the algorithm robust to sample-wise (column-wise) outliers.\n\nArguments\n\nX::AbstractMatrix: Data matrix (m × n)\nF::AbstractMatrix: Current basis matrix (m × rank)\nG::AbstractMatrix: Current coefficient matrix (rank × n)\n\nKeyword Arguments\n\neps_update::Float64=1e-10: Small constant for numerical stability\n\nReturns\n\nF_new::Matrix{Float64}: Updated basis matrix\nG_new::Matrix{Float64}: Updated coefficient matrix\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.l21norm","page":"Functions","title":"RobustNMF.l21norm","text":"l21norm(X)\n\nCompute the L2,1-norm of matrix X. The L2,1-norm is the sum of the L2-norms of each column.\n\nArguments\n\nX::AbstractMatrix: Input matrix\n\nReturns\n\nScalar value: sum of L2-norms of columns\n\nExamples\n\nX = [1.0 2.0; 3.0 4.0]\nl21norm(X)  # Returns norm([1,3]) + norm([2,4])\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.generate_synthetic_data","page":"Functions","title":"RobustNMF.generate_synthetic_data","text":"generate_synthetic_data(m::Int, n::Int; rank::Int=10, noise_level::Float64=0.0, seed=nothing)\n\nGenerate a non-negative matrix X ∈ R^{m×n} by sampling non-negative factors W (m×rank) and H (rank×n) and returning (X, W, H).\n\nOptionally add Gaussian noise with standard deviation noise_level and clip the result at 0.0 to keep X non-negative.\n\nArguments\n\nm::Int: Number of rows of X.\nn::Int: Number of columns of X.\n\nKeyword Arguments\n\nrank::Int=10: Rank of the factorization.\nnoise_level::Float64=0.0: Standard deviation of Gaussian noise.\nseed: Optional random seed for reproducibility.\n\nReturns\n\nX::Matrix{Float64}: Generated non-negative data matrix.\nW::Matrix{Float64}: Left factor.\nH::Matrix{Float64}: Right factor.\n\nExamples\n\njulia> X, W, H = generate_synthetic_data(20, 15; rank=3, seed=42);\n\njulia> size(W), size(H)\n((20, 3), (3, 15))\n\njulia> minimum(X) >= 0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.add_gaussian_noise!","page":"Functions","title":"RobustNMF.add_gaussian_noise!","text":"add_gaussian_noise!(X::AbstractMatrix; σ::Float64=0.1, clip_at_zero::Bool=true)\n\nAdd Gaussian noise with standard deviation σ to the matrix X in-place.\n\nIf clip_at_zero is true, replace all negative entries of X with 0.0 after adding noise, to preserve non-negativity.\n\nArguments\n\nX::AbstractMatrix: Data matrix to be corrupted.\n\nKeyword Arguments\n\nσ::Float64=0.1: Noise standard deviation.\nclip_at_zero::Bool=true: Enforce non-negativity after corruption.\n\nReturns\n\nX: The modified input matrix.\n\nExamples\n\njulia> X = abs.(randn(5, 5));\n\njulia> add_gaussian_noise!(X; σ=0.2);\n\njulia> minimum(X) >= 0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.add_sparse_outliers!","page":"Functions","title":"RobustNMF.add_sparse_outliers!","text":"add_sparse_outliers!(X::AbstractMatrix; fraction::Float64=0.01, magnitude::Float64=5.0, \nseed=nothing)\n\nAdd sparcse, large positive outliers to a fraction of the entries of X in-place.\n\nfraction controls the proportion of entries that are modified. Each selected entry is increased by a random value drawn from Uniform(0, magnitude). If seed is provided, the random choices are reproducible.\n\nArguments\n\nX::AbstractMatrix: Data matrix to be corrupted.\n\nKeyword Arguments\n\nfraction::Float64=0.01: Fraction of entries to corrupt.\nmagnitude::Float64=5.0: Maximum outlier amplitude.\nseed: Optional random seed.\n\nReturns\n\nX: The modified input matrix.\n\nExamples\n\njulia> X = zeros(10, 10);\n\njulia> add_sparse_outliers!(X; fraction=0.05, seed=1);\n\njulia> count(x -> x > 0, X) > 0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.normalize_nonnegative!","page":"Functions","title":"RobustNMF.normalize_nonnegative!","text":"normalize_nonnegative!(X::AbstractMatrix; rescale::Bool=true)\n\nShift the matrix X in-place so that its minimum value becomes 0.0 if it is negative. If rescale is true, also divide X by its maximum value so that all entries lie in the interval [0, 1].\n\nArguments\n\nX::AbstractMatrix: Input matrix.\n\nKeyword Arguments\n\nrescale::Bool=true: Whether to divide by the maximum value.\n\nReturns\n\nX: The normalized matrix.\n\nExamples\n\njulia> X = [-1.0 2.0; 3.0 -4.0];\n\njulia> normalize_nonnegative!(X);\n\njulia> minimum(X), maximum(X)\n(0.0, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.load_image_folder","page":"Functions","title":"RobustNMF.load_image_folder","text":"load_image_folder(dir::AbstractString; pattern::AbstractString=\"*.png\", normalize::Bool=true)\n\nLoad all images in dir whose filenames match pattern, convert them to grayscale if needed, flatten them, and stack them as columns of a data matrix X.\n\nReturns a tuple (X, (height, width), filenames), where:\n\nX :: Matrix{Float64} has one column per image,\n(height, width) is the original image size,\nfilenames is a vector of the loaded base filenames.\n\nIf normalize is true, the matrix X is shifted and rescaled to be non-negative with entries in [0, 1].\n\nArguments\n\ndir::AbstractString: Path to the image directory.\n\nKeyword Arguments\n\npattern::AbstractString=\"*.png\": File extension filter.\nnormalize::Bool=true: Normalize output matrix to [0, 1].\n\nReturns\n\nX::Matrix{Float64}: One column per image.\n(height, width): Original image dimensions.\nfilenames::Vector{String}: Loaded file names.\n\nExamples\n\njulia> # X, size, names = load_image_folder(\"faces/\")\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.plot_convergence","page":"Functions","title":"RobustNMF.plot_convergence","text":"plot_convergence(history::Vector; title::String=\"NMF Convergence\",\n                ylabel::String=\"Frobenius Error\", log_scale::Bool=true)\n\nPlot the convergence history of the NMF algorithm.\n\nArguments\n\nhistory::Vector: Vector of error values at each iteration.\n\nKeyword Arguments\n\ntitle::String: Plot title.\nylabel::String: Y-axis label.\nlog_scale::Bool=true: Use logarithmic scale for y-axis.\n\nReturns\n\nA Plots.Plot object.\n\nExamples\n\nW, H, history = nmf(X; rank=10, maxiter=500)\nplot_convergence(history)\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.plot_basis_vectors","page":"Functions","title":"RobustNMF.plot_basis_vectors","text":"plot_basis_vectors(W::AbstractMatrix; img_shape=nothing, max_components::Int=16, \n                  title::String=\"Basis Vectors (W)\", layout=nothing)\n\nVisualize the basis vectors (columns of W) as heatmaps or images.\n\nArguments\n\nW::AbstractMatrix: Basis matrix of size (m, rank).\n\nKeyword Arguments\n\nimg_shape: Tuple (height, width) to reshape each basis vector as an image.               If nothing, displays as 1D heatmaps.\nmax_components::Int=16: Maximum number of components to display.\ntitle::String: Plot title.\nlayout: Custom layout tuple (rows, cols). If nothing, auto-computed.\n\nReturns\n\nA Plots.Plot object showing the basis vectors.\n\nExamples\n\nW, H, _ = nmf(X; rank=10)\nplot_basis_vectors(W; max_components=10)\n\n# For image data with known dimensions\nplot_basis_vectors(W; img_shape=(28, 28), max_components=16)\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.plot_reconstruction_comparison","page":"Functions","title":"RobustNMF.plot_reconstruction_comparison","text":"plot_reconstruction_comparison(X_original::AbstractMatrix, X_recon::AbstractMatrix;\n                               img_shape=nothing, n_samples::Int=5,\n                               title::String=\"Reconstruction Comparison\")\n\nCompare original data with reconstructed data side by side.\n\nArguments\n\nX_original::AbstractMatrix: Original data matrix.\nX_recon::AbstractMatrix: Reconstructed data matrix (W * H).\n\nKeyword Arguments\n\nimg_shape: Tuple (height, width) for reshaping columns as images.\nn_samples::Int=5: Number of samples to display.\ntitle::String: Plot title.\n\nReturns\n\nA Plots.Plot object showing original vs reconstructed samples.\n\nExamples\n\nW, H, _ = nmf(X; rank=10)\nX_recon = W * H\nplot_reconstruction_comparison(X, X_recon; img_shape=(28, 28), n_samples=6)\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.plot_nmf_summary","page":"Functions","title":"RobustNMF.plot_nmf_summary","text":"plot_nmf_summary(X::AbstractMatrix, W::AbstractMatrix, H::AbstractMatrix, \n                history::Vector; img_shape=nothing, max_basis::Int=9,\n                max_samples::Int=4)\n\nCreate a comprehensive summary plot showing basis vectors, sample reconstructions, and convergence in a single figure.\n\nArguments\n\nX::AbstractMatrix: Original data matrix.\nW::AbstractMatrix: Basis matrix.\nH::AbstractMatrix: Coefficient matrix.\nhistory::Vector: Convergence history.\n\nKeyword Arguments\n\nimg_shape: Tuple (height, width) for image data.\nmax_basis::Int=9: Maximum number of basis vectors to show.\nmax_samples::Int=4: Maximum number of reconstruction comparisons.\n\nReturns\n\nA Plots.Plot object with a comprehensive summary.\n\nExamples\n\nW, H, history = nmf(X; rank=10)\nplot_nmf_summary(X, W, H, history; img_shape=(28, 28))\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.plot_activation_coefficients","page":"Functions","title":"RobustNMF.plot_activation_coefficients","text":"plot_activation_coefficients(H::AbstractMatrix; max_samples::Int=10, \n                             title::String=\"Activation Coefficients (H)\")\n\nVisualize the activation coefficient matrix H as a heatmap or as individual sample profiles.\n\nArguments\n\nH::AbstractMatrix: Coefficient matrix of size (rank, n).\n\nKeyword Arguments\n\nmax_samples::Int=10: Maximum number of samples to display (if showing individual profiles).\ntitle::String: Plot title.\n\nReturns\n\nA Plots.Plot object.\n\nExamples\n\nW, H, _ = nmf(X; rank=10)\nplot_activation_coefficients(H)\n\n\n\n\n\n","category":"function"},{"location":"functions/#RobustNMF.plot_image_reconstruction","page":"Functions","title":"RobustNMF.plot_image_reconstruction","text":"plot_image_reconstruction(X::AbstractMatrix, W::AbstractMatrix, H::AbstractMatrix,\n                         img_shape::Tuple{Int,Int}; indices=nothing, n_images::Int=5)\n\nSpecialized function for visualizing image reconstruction quality. Shows original, reconstructed, and difference images side by side.\n\nArguments\n\nX::AbstractMatrix: Original image data (each column is a flattened image).\nW::AbstractMatrix: Basis matrix.\nH::AbstractMatrix: Coefficient matrix.\nimg_shape::Tuple{Int,Int}: Image dimensions (height, width).\n\nKeyword Arguments\n\nindices: Specific image indices to display. If nothing, randomly selected.\nn_images::Int=5: Number of images to display.\n\nReturns\n\nA Plots.Plot object.\n\nExamples\n\nW, H, _ = nmf(X; rank=20)\nplot_image_reconstruction(X, W, H, (64, 64); n_images=6)\n\n\n\n\n\n","category":"function"},{"location":"#Getting-Started-with-RobustNMF.jl","page":"Getting Started","title":"Getting Started with RobustNMF.jl","text":"","category":"section"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"Clone the repository and activate the project environment. The following steps work when executed from the repository root directory.\n\n# Enter the Julia package manager\n]\n\n# Activate the local project environment\nactivate .\n\n# Install all required dependencies\ninstantiate","category":"section"},{"location":"#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"Import the package:\n\nusing RobustNMF","category":"section"},{"location":"#Simple-Example","page":"Getting Started","title":"Simple Example","text":"Perform robust non-negative matrix factorization:\n\n\n# Generate synthetic non-negative data\nX, W, H = generate_synthetic_data(20, 30)\n\n# Add Gaussian noise (in-place)\nadd_gaussian_noise!(X, σ = 0.2)\n\n# Add sparse outliers (in-place)\nadd_sparse_outliers!(X, fraction = 0.04, magnitude = 5.2)\n\n# Normalize and rescale data to non-negative range\nnormalize_nonnegative!(X)\n\n# Run standard NMF\nW_nmf, H_nmf, history = nmf(X, rank = 12, maxiter = 3000, tol = 1e-6)\n\n# Reconstruct the data matrix (X)\nX_rec = W_nmf * H_nmf\n\n# Run robust NMF\nW_robust, H_robust, history_robust = robust_nmf(X, rank = 12, maxiter = 3000, tol = 1e-6)\n\n\n","category":"section"},{"location":"#Notes","page":"Getting Started","title":"Notes","text":"All input data must be non-negative.\nFunctions with a ! modify their input in-place.\nThe reconstructed matrix X_rec approximates the original data X.","category":"section"}]
}
